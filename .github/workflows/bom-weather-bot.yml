name: BoM Weather Forecast

on:
  schedule:
    # Runs at 9:30 AM Melbourne time (10:30 PM UTC previous day) - 30 mins after Open-Meteo bot
    - cron: '30 22 * * *'
  workflow_dispatch: # Allows manual testing

jobs:
  send-weather:
    runs-on: ubuntu-latest
    
    steps:
    - name: Send BoM Weather Forecast
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        echo "Fetching BoM weather data and sending to Telegram..."
        
        python3 << 'PYTHON_SCRIPT'
        import json
        import urllib.request
        import urllib.parse
        import os
        from datetime import datetime, timezone, timedelta
        import re
        
        # Get secrets from environment
        bot_token = os.environ['TELEGRAM_BOT_TOKEN']
        chat_id = os.environ['TELEGRAM_CHAT_ID']
        
        # Get today's date in Melbourne timezone
        melbourne_offset = timedelta(hours=11)
        melbourne_tz = timezone(melbourne_offset)
        now_melbourne = datetime.now(timezone.utc).astimezone(melbourne_tz)
        
        # Target date to stop
        target_date = datetime(2025, 12, 5, tzinfo=melbourne_tz)
        
        # Check if we should still run
        if now_melbourne.date() > target_date.date():
            print("Stop date reached. No longer sending forecasts.")
            exit(0)
        
        # Fetch BoM forecast page
        url = "https://www.bom.gov.au/places/vic/meredith/forecast/"
        
        try:
            req = urllib.request.Request(url, headers={'User-Agent': 'Mozilla/5.0'})
            with urllib.request.urlopen(req) as response:
                html = response.read().decode('utf-8')
        except Exception as e:
            print(f"Error fetching BoM data: {e}")
            exit(1)
        
        # Parse the forecast data
        def extract_forecast(html, date_str):
            """Extract forecast for a specific date from BoM HTML."""
            # Look for the date heading and forecast data
            pattern = f'{date_str}.*?Min.*?(\d+).*?Max.*?(\d+).*?Possible rainfall:.*?([\d\.]+ to [\d\.]+ mm|0 mm|0 to [\d\.]+ mm).*?Chance of any rain:.*?(\d+)%'
            match = re.search(pattern, html, re.DOTALL)
            
            if match:
                min_temp = match.group(1)
                max_temp = match.group(2)
                rainfall = match.group(3)
                rain_chance = match.group(4)
                
                # Extract description - look for text after "Central area"
                desc_pattern = f'{date_str}.*?Central area\s+(.*?)(?:Sun protection|Fire Danger|Winds |Overnight temperatures)'
                desc_match = re.search(desc_pattern, html, re.DOTALL)
                
                if desc_match:
                    description = desc_match.group(1).strip()
                    # Clean up: remove extra whitespace, limit length
                    description = re.sub(r'\s+', ' ', description)
                    # Take first sentence or two (up to 150 chars)
                    if len(description) > 150:
                        description = description[:150].rsplit('.', 1)[0] + '.'
                else:
                    # Fallback: try to get any text between the date and next section
                    fallback_pattern = f'{date_str}.*?Central area(.*?)(?:Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday|The next routine)'
                    fallback_match = re.search(fallback_pattern, html, re.DOTALL)
                    if fallback_match:
                        description = fallback_match.group(1).strip()[:100]
                        description = re.sub(r'\s+', ' ', description)
                    else:
                        # Just extract the precis/summary
                        precis_pattern = f'{date_str}.*?Precis\s+(.*?)(?:Possible rainfall)'
                        precis_match = re.search(precis_pattern, html, re.DOTALL)
                        description = precis_match.group(1).strip() if precis_match else "Partly cloudy"
                
                return {
                    'min': min_temp,
                    'max': max_temp,
                    'rainfall': rainfall,
                    'rain_chance': rain_chance,
                    'description': description
                }
            return None
        
        # Build message
        message = "â˜€ï¸ BoM Weather Forecast for Meredith, VIC\n\n"
        
        # Get today's forecast
        today_str = now_melbourne.strftime('%A %d %B')
        if 'rest of' in html.lower():
            today_str = 'rest of ' + now_melbourne.strftime('%A')
        
        # Extract today if available
        today_pattern = r'(?:rest of|Today).*?Min.*?(\d+).*?Max.*?(\d+).*?Possible rainfall:.*?([\d\.]+ to [\d\.]+ mm|0 mm|0 to [\d\.]+ mm).*?Chance of any rain:.*?(\d+)%'
        today_match = re.search(today_pattern, html, re.DOTALL | re.IGNORECASE)
        
        if today_match:
            message += f"TODAY ({now_melbourne.strftime('%A %d %B')}):\n"
            message += f"ğŸŒ¡ï¸ High: {today_match.group(2)}Â°C / Low: {today_match.group(1)}Â°C\n"
            message += f"ğŸ’§ Rain: {today_match.group(3)} ({today_match.group(4)}% chance)\n\n"
            message += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        
        # Target dates for festival
        target_dates = [
            ('Friday 5 December', 'Friday, December 5, 2025'),
            ('Saturday 6 December', 'Saturday, December 6, 2025'),
            ('Sunday 7 December', 'Sunday, December 7, 2025')
        ]
        
        for date_str, display_name in target_dates:
            forecast = extract_forecast(html, date_str)
            
            if forecast:
                message += f"{display_name}:\n"
                message += f"ğŸŒ¡ï¸ High: {forecast['max']}Â°C / Low: {forecast['min']}Â°C\n"
                message += f"ğŸ’§ Rain: {forecast['rainfall']} ({forecast['rain_chance']}% chance)\n"
                message += f"â˜ï¸ {forecast['description']}\n\n"
            else:
                message += f"{display_name}:\n"
                message += "Forecast not yet available\n\n"
        
        message += f"ğŸ“Š Source: Bureau of Meteorology\n"
        message += f"Updated: {now_melbourne.strftime('%I:%M %p')}"
        
        # Send to Telegram
        telegram_url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
        data = urllib.parse.urlencode({
            'chat_id': chat_id,
            'text': message,
            'disable_web_page_preview': True
        }).encode()
        
        req = urllib.request.Request(telegram_url, data=data)
        
        try:
            with urllib.request.urlopen(req) as response:
                result = json.loads(response.read())
                if result.get('ok'):
                    print("âœ… BoM weather forecast sent successfully!")
                else:
                    print(f"Telegram error: {result}")
        except Exception as e:
            print(f"Error sending to Telegram: {e}")
            exit(1)
        PYTHON_SCRIPT
