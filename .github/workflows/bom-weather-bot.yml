name: BoM Weather Forecast

on:
  schedule:
    # Runs at 9:30 AM Melbourne time (10:30 PM UTC previous day) - 30 mins after Open-Meteo bot
    - cron: '30 22 * * *'
  workflow_dispatch: # Allows manual testing

jobs:
  send-weather:
    runs-on: ubuntu-latest
    
    steps:
    - name: Send BoM Weather Forecast
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        echo "Fetching BoM weather data and sending to Telegram..."
        
        python3 << 'PYTHON_SCRIPT'
        import json
        import urllib.request
        import urllib.parse
        import os
        from datetime import datetime, timezone, timedelta
        import re
        
        # Get secrets from environment
        bot_token = os.environ['TELEGRAM_BOT_TOKEN']
        chat_id = os.environ['TELEGRAM_CHAT_ID']
        
        # Get today's date in Melbourne timezone
        melbourne_offset = timedelta(hours=11)
        melbourne_tz = timezone(melbourne_offset)
        now_melbourne = datetime.now(timezone.utc).astimezone(melbourne_tz)
        
        # Target date to stop
        target_date = datetime(2025, 12, 5, tzinfo=melbourne_tz)
        
        # Check if we should still run
        if now_melbourne.date() > target_date.date():
            print("Stop date reached. No longer sending forecasts.")
            exit(0)
        
        # Fetch BoM forecast page
        url = "https://www.bom.gov.au/places/vic/meredith/forecast/"
        
        try:
            req = urllib.request.Request(url, headers={'User-Agent': 'Mozilla/5.0'})
            with urllib.request.urlopen(req) as response:
                html = response.read().decode('utf-8')
        except Exception as e:
            print(f"Error fetching BoM data: {e}")
            exit(1)
        
        # Parse the forecast data
        def extract_forecast(html, date_str):
            """Extract forecast for a specific date from BoM HTML."""
            # Look for the date heading
            pattern = f'{date_str}.*?Min.*?(\d+).*?Max.*?(\d+).*?Precis.*?Possible rainfall:.*?([\d\.]+ to [\d\.]+ mm|0 mm|0 to [\d\.]+ mm).*?Chance of any rain:.*?(\d+)%'
            match = re.search(pattern, html, re.DOTALL)
            
            if match:
                min_temp = match.group(1)
                max_temp = match.group(2)
                rainfall = match.group(3)
                rain_chance = match.group(4)
                
                # Extract description
                desc_pattern = f'{date_str}.*?Central area\s+(.*?)(?:Sun protection|Fire Danger|Overnight temperatures)'
                desc_match = re.search(desc_pattern, html, re.DOTALL)
                description = desc_match.group(1).strip()[:200] if desc_match else "No description available"
                # Clean up description
                description = re.sub(r'\s+', ' ', description)
                
                return {
                    'min': min_temp,
                    'max': max_temp,
                    'rainfall': rainfall,
                    'rain_chance': rain_chance,
                    'description': description
                }
            return None
        
        # Build message
        message = "‚òÄÔ∏è BoM Weather Forecast for Meredith, VIC\n\n"
        
        # Get today's forecast
        today_str = now_melbourne.strftime('%A %d %B')
        if 'rest of' in html.lower():
            today_str = 'rest of ' + now_melbourne.strftime('%A')
        
        # Extract today if available
        today_pattern = r'(?:rest of|Today).*?Min.*?(\d+).*?Max.*?(\d+).*?Possible rainfall:.*?([\d\.]+ to [\d\.]+ mm|0 mm|0 to [\d\.]+ mm).*?Chance of any rain:.*?(\d+)%'
        today_match = re.search(today_pattern, html, re.DOTALL | re.IGNORECASE)
        
        if today_match:
            message += f"TODAY ({now_melbourne.strftime('%A %d %B')}):\n"
            message += f"üå°Ô∏è High: {today_match.group(2)}¬∞C / Low: {today_match.group(1)}¬∞C\n"
            message += f"üíß Rain: {today_match.group(3)} ({today_match.group(4)}% chance)\n\n"
            message += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        
        # Target dates for festival
        target_dates = [
            ('Friday 5 December', 'December 5, 2025'),
            ('Saturday 6 December', 'December 6, 2025'),
            ('Sunday 7 December', 'December 7, 2025')
        ]
        
        for date_str, display_name in target_dates:
            forecast = extract_forecast(html, date_str)
            
            if forecast:
                message += f"{display_name}:\n"
                message += f"üå°Ô∏è High: {forecast['max']}¬∞C / Low: {forecast['min']}¬∞C\n"
                message += f"üíß Rain: {forecast['rainfall']} ({forecast['rain_chance']}% chance)\n"
                message += f"‚òÅÔ∏è {forecast['description']}\n\n"
            else:
                message += f"{display_name}:\n"
                message += "Forecast not yet available\n\n"
        
        message += f"üìä Source: Bureau of Meteorology\n"
        message += f"Updated: {now_melbourne.strftime('%I:%M %p')}"
        
        # Send to Telegram
        telegram_url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
        data = urllib.parse.urlencode({
            'chat_id': chat_id,
            'text': message,
            'disable_web_page_preview': True
        }).encode()
        
        req = urllib.request.Request(telegram_url, data=data)
        
        try:
            with urllib.request.urlopen(req) as response:
                result = json.loads(response.read())
                if result.get('ok'):
                    print("‚úÖ BoM weather forecast sent successfully!")
                else:
                    print(f"Telegram error: {result}")
        except Exception as e:
            print(f"Error sending to Telegram: {e}")
            exit(1)
        PYTHON_SCRIPT
